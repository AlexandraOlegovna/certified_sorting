
В этой статье мы попробуем формализовать и доказать корректность одного (или нескольких) алгоритмов сортировки с помощью *Coq proof assistant*.


Для этого нам потребуется определить что значит, что некоторый список отсортирован.
Пусть нам дан список *l* с целочисленными элементами. Тогда этот список будем называть отсортированным, если все элементы списка расположены в возрастающем порядке (то есть каждый следующий больше или равен предыдущему). В свою очередь, алгоритм сортировки принимает на вход некоторый список l и должен возвращать список *l'*, который является отсортированным и помимо этого должен являться некоторой перестановкой элементов списка *l*.

Формализуем это эти свойства с помощью следующих выражений.

Чтобы определить предикат "отсортированный список", следует рассмотреть три случая:
    1. пустой список отсортирован
    2. список из одного элемента также отсортирован
    3. если некоторый список *l = n :: l'* (где *n* - голова списка, а *l'* - хвост списка) отсортирован, то если добавить любое число *p*, меньшее *n*, в начало списка, то результат *(p :: n :: l)* также будет являться отсортированным списком.

Такой тип определения называется индуктивным (или рекурсивным) и позволяет определять некоторую сущность в терминах ее самой. При этом пункты 1. и 2. являются базисом индукции, а пункт 3. индуктивным выражением.

С помощью Coq этот предикат может быть записан следующим образом.


    Inductive sorted : list Z -> Prop :=
    | sorted0 : sorted nil
    | sorted1 : forall z:Z, sorted (z :: nil)
    | sorted2 :
      forall (z1 z2:Z) (l:list Z),
        z1 <= z2 ->
        sorted (z2 :: l) -> sorted (z1 :: z2 :: l).


Теперь шагом сформируем бинарное отношение между двумя списками, которое определяет, что два списка имеют одни и те же элементы, то есть являются перестановками друг друга.
Для этого мы опишем функцию, которая возвращает число вхождений некоторого числа *z* в список *l*, иначе говоря сколько раз *z* встречается в списке *l*. Назовем эту функцию *nb_occ*, и ее тип будет следующий *"Z -> list Z -> nat"*. Следующим шагом на основе этой функции определим бинарное отношение эквивалентности двух списков:
    *l ~ l' <-> ∀ z : Z, nb_occ z l = nb_occ z l'*

Это соотношение удовлетворяет следующим свойствам:
    *equiv_cons : ∀ z:Z, ∀ l l':list Z, l ~ l' -> (z :: l) ~ (z :: l').*
    *equiv_perm : ∀ a b:Z, ∀ l l':list Z, l ~ l' -> (a :: b :: l) ~ (b :: a :: l').*
    *equiv_trans : ∀ l l' l'':list Z, l ~ l' -> l' ~ l'' -> l ~ l''.*



Таким образом, мы получили все необходимое, чтобы определить тип *Z_sort*. Терм такого типа должен сопоставлять любому списку *l* некоторый список *l'*, удовлетворяющий предикату *sorted(l') /\ l ~ l'*.


Далее будем рассматривать сортирвку вставками. Этот алгоритм опирается на вспомогательную функцию, которая вставляет элементы уже в отсортированный список. Назовем эту функцию aux, и ее тип будет следующий *"Z -> list Z -> list Z"*. Нетрудно определить эту функцию рекурсивно следующим образом:

    *n* - элемент для вставки, *l* - список

    если список l пуст, то возвращаем список из одного элемента *[n]*
    иначе список не пуст, то есть *l = p :: l'*, тогда
        если  *n <= p*, то возвращаем список *n :: p :: l'*
        иначе (*p < n*), рекурсивно вызываем функцию aux для формирования списка: *p :: aux (n l')*

C помощью Coq данная функция может быть реализована следующим образом:

    Fixpoint aux (z:Z) (l:list Z) : list Z :=
    match l with
    | [] => z :: []
    | a :: l' =>
      match Z_le_gt_dec z a with
      | left _ =>  z :: a :: l'
      | right _ => a :: (aux z l')
      end
    end.

Функция из стандартной библиотеки *Coq* *Z_le_gt_dec* определяет порядок *<=* для двух целочисленных аргументов (её тип: *∀ x y : Z, {x <= y} + {x > y}*). Таким образом, выполнение условия *'left _'* гарантирует, что *'z <= a'*, а выполнение *'right _'* -- *'z > a'*.

Функция aux удовлетворяет следующим свойствам, которые можно доказать с помощью индукции по длине списка *l*.
    *aux_equiv : ∀ l:list Z, ∀ x:Z, (x :: l) ~ (aux x l).*
    *aux_sorted : ∀ l:list Z, ∀ x:Z, sorted l -> sorted (aux x l).*

Докажем в качестве примера свойство aux_equiv.
    1) если список l = *[]*,
        тогда c одной стороны:
            *x :: l => x :: [] => [x]*
        с другой стороны:
            *aux x l => aux x [] => [x]*

        *[x] ~ [x]* - верно
    2) пусть *(x :: l) ~ (aux x l)*, докажем, что *(x :: a :: l) ~ (aux x (a :: l))*
        упростим функцию aux и разобьём её на два случая: когда *x <= a* и *a < x*

        a) *x <= a*, тогда *(x :: a :: l) ~ (x :: a :: l)* - верно

        b) a < x, тогда надо доказать, что *(x :: a :: l') ~ (a :: (aux x l'))*.
            Ясно, что *(a :: x :: l) ~ (x :: a :: l)* -- свойство *equiv_perm* (при доказанном ранее условии, что *l ~ l'*).
            Ясно, что *(a :: x :: l) ~ (a :: (aux x l))* -- свойство *equiv_cons*.
        Тогда с помощью свойства equiv_trans равенство *(x :: a :: l')* ~ *(a :: (aux x l'))* доказано.

Осталось построить только программу, специфицирующую сортировку.
Определим ее с помощью индукции по длине списка l.

    если *l = []*, то *l' = []*, так как *(sorted []) /\ ([] ~ [])* - истина
    если *l = n :: ll*, тогда пусть существует список *ll'*, что sorted *(ll')* и *(ll ~ ll')*.
        Пусть *l' = aux n ll'*.
        Тогда из sorted *(ll') => sorted (l')* - истина -- лемма *aux_sorted*.
        Тогда *l = n :: ll ~ n :: ll' (equiv_cons) ~ aux n ll' (aux_equiv) = l'*
    *sorted (l') /\ l ~ l'.*

    Таким образом, на выходе мы получили терм типа *Z_sort*, другими словами программу, специфицирующую сортировку.

В отличии от бумаги или доски, где при доказательстве теорем и лемм возможен шанс возникновения ошибки или неточности, *Coq* является отличным средством для того, чтобы записывать математические теоремы и их доказательства, удобно модифицировать их, проверять их на правильность.
